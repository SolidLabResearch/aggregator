package registration

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/lestrrat-go/jwx/jwk"
	"github.com/lestrrat-go/jwx/jwt"
)

// OIDCConfig represents the relevant fields from the OpenID configuration
type OIDCConfig struct {
	Issuer                      string `json:"issuer"`
	DeviceAuthorizationEndpoint string `json:"device_authorization_endpoint"`
	TokenEndpoint               string `json:"token_endpoint"`
	JWKSURI                     string `json:"jwks_uri"`
}

// deviceSession represents a background device flow polling session
type deviceSession struct {
	OIDCConfig  OIDCConfig
	AuthzServer string
	DeviceCode  string
	Interval    int
	ExpiresAt   time.Time
	CallbackURI string
}

// DeviceCodeResponse represents the response from the IdP device authorization endpoint
type DeviceCodeResponse struct {
	DeviceCode      string `json:"device_code"`
	UserCode        string `json:"user_code"`
	VerificationURI string `json:"verification_uri"`
	ExpiresIn       int    `json:"expires_in"`
	Interval        int    `json:"interval"`
}

// fetchOIDCConfig fetches and parses the OIDC discovery document for the given IdP
func fetchOIDCConfig(idpURL string) (*OIDCConfig, error) {
	discoveryURL := fmt.Sprintf("%s/.well-known/openid-configuration", idpURL)

	res, err := http.Get(discoveryURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch OIDC discovery document: %w", err)
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("OIDC discovery returned non-OK status: %s", res.Status)
	}

	var cfg OIDCConfig
	if err := json.NewDecoder(res.Body).Decode(&cfg); err != nil {
		return nil, fmt.Errorf("failed to decode OIDC discovery JSON: %w", err)
	}

	if cfg.DeviceAuthorizationEndpoint == "" || cfg.TokenEndpoint == "" {
		return nil, fmt.Errorf("OIDC config missing required endpoints")
	}

	return &cfg, nil
}

// validateToken checks standard claims of the token. and returns the user id if valid.
func validateToken(tokenString string, idp string) (string, error) {
	// Verify token
	token, err := verifyToken(tokenString, idp)
	if err != nil {
		return "", fmt.Errorf("failed to verify token: %w", err)
	}

	// Check expiration
	exp := token.Expiration()
	if time.Now().After(exp) {
		return "", fmt.Errorf("token has expired")
	}

	// Check issuer
	iss, ok := token.Get("iss")
	if !ok || iss.(string) != idp {
		return "", fmt.Errorf("invalid issuer")
	}
	// Extract user id (sub claim)
	sub, ok := token.Get("sub")
	if !ok {
		return "", fmt.Errorf("sub claim not found")
	}

	userID, ok := sub.(string)
	if !ok {
		return "", fmt.Errorf("invalid sub claim type")
	}

	return userID, nil
}

// verifyToken verifies the JWT using the issuer's JWKS endpoint.
// Returns the parsed token if valid.
func verifyToken(tokenString string, issuer string) (jwt.Token, error) {
	// Build JWKS URL from issuer
	jwksURL := fmt.Sprintf("%s/protocol/openid-connect/certs", issuer)

	// Fetch JWKS from IdP
	keySet, err := jwk.Fetch(context.Background(), jwksURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch JWKS: %w", err)
	}

	// Parse and verify token using the key set
	token, err := jwt.Parse([]byte(tokenString), jwt.WithKeySet(keySet))
	if err != nil {
		return nil, fmt.Errorf("invalid token: %w", err)
	}

	return token, nil
}
